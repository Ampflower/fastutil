/*
 * Copyright (C) 2002-2017 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package PACKAGE;

import java.util.Collection;
import java.util.Spliterators;
import static it.unimi.dsi.fastutil.Size64.getSizeOf;
#if KEY_WIDENED
import WIDENED_PACKAGE.KEY_WIDENED_ITERATOR;
import WIDENED_PACKAGE.WIDENED_ITERATORS;
import WIDENED_PACKAGE.KEY_WIDENED_SPLITERATOR;
import WIDENED_PACKAGE.WIDENED_SPLITERATORS;
#endif

/** A type-specific {@link Collection}; provides some additional methods
 * that use polymorphism to avoid (un)boxing.
 *
 * <p>Additionally, this class defines strengthens (again) {@link #iterator()}.
 *
 * @see Collection
 */

public interface COLLECTION KEY_GENERIC extends Collection<KEY_GENERIC_CLASS>, KEY_ITERABLE KEY_GENERIC {

	/** Returns a type-specific iterator on the elements of this collection.
	 *
	 * <p>Note that this specification strengthens the one given in
	 * {@link java.lang.Iterable#iterator()}, which was already
	 * strengthened in the corresponding type-specific class,
	 * but was weakened by the fact that this interface extends {@link Collection}.
	 *
	 * @return a type-specific iterator on the elements of this collection.
	 */
	@Override
	KEY_ITERATOR KEY_GENERIC iterator();

#if defined JDK_PRIMITIVE_ITERATOR && KEY_WIDENED && SMALL_TYPES
	/**
	 * Returns a widened primitive iterator on the elements of this collection.<p>
	 *
	 * This method is provided for the purpose of APIs that expect only the JDK's
	 * primitive iterators, of which there are only {@code int}, {@code long}, and {@code double}.
	 *
	 * @return a widened primitive iterator on the elements of this collection.
	 * @since 8.3.0
	 */
	@Override
	default KEY_WIDENED_ITERATOR KEY_WIDENED_ITERATOR_METHOD() {
		return WIDENED_ITERATORS.wrap(iterator());
	}
#elif defined JDK_PRIMITIVE_ITERATOR && KEYS_PRIMITIVE && !KEY_WIDENED && SMALL_TYPES
	/** Returns a primitive iterator on the elements of this collection.<p>
	 *
	 * This method is identical to {@link #iterator()}, as the type-specific
	 * iterator is already compatible with the JDK's primitive iterators.
	 * It only exists for compatibility with the other primitive types' {@code Collection}s
	 * that have use for widened iterators.
	 *
	 * @return a primitive iterator on the elements of this collection.
	 * @since 8.3.0
	 */
	@Override
	default KEY_WIDENED_ITERATOR KEY_WIDENED_ITERATOR_METHOD() { return iterator(); }
#endif

	// If you change these default spliterator methods, you will likely need to update Iterable, List, Set, and SortedSet too

	/** Returns a type-specific spliterator on the elements of this collection.
	 *
	 * <p>Note that this specification strengthens the one given in
	 * {@link java.util.Collection#spliterator()}.
	 *
	 * <p>If you are implementing your own primitive collection type and override this method,
	 * you will likely want have your class additionally implement your specific types'
	 * {@link ImplementsSpliterator} interface. That will signal to the default methods that
	 * this type has an explicit spliterator overriden implementation, and thus shouldn't assume
	 * this this method could call other default methods (allowing other default methods to use
	 * your spliterator, instead of a default one.)
	 * 
	 * @return a type-specific spliterator on the elements of this collection.
	 * @since 8.3.0
	 */
	@Override
#if SPLITERATOR_ASSURE_OVERRIDE
	abstract KEY_SPLITERATOR KEY_GENERIC spliterator();
#else
	default KEY_SPLITERATOR KEY_GENERIC spliterator() {
#if (defined JDK_PRIMITIVE_SPLITERATOR && !KEY_WIDENED) || KEYS_REFERENCE || KEY_CLASS_Boolean
#if KEY_CLASS_Boolean
		// TODO this default implementation boxes and unboxes, which is not ideal.
		// But to fix that would require either reimplementing Spliterators.spliterator(Iterable) for BooleanIterable.
		// Or provide a view to expose BooleanCollection as ints C style and then wrap Spliterators.spliterator(Spliterator.OfInt).
#endif
		return SPLITERATORS.AS_KEY_SPLITERATOR(Spliterators.spliterator(
				iterator(), getSizeOf(this), SPLITERATORS.COLLECTION_SPLITERATOR_CHARACTERISTICS));
#else
		return SPLITERATORS.narrow(KEY_WIDENED_SPLITERATOR_METHOD());
#endif
	}
#endif

#if defined JDK_PRIMITIVE_SPLITERATOR && KEY_WIDENED
	/** Returns widened primitive spliterator on the elements of this collection.<p>
	 *
	 * This method is provided for the purpose of APIs that expect only the JDK's
	 * primitive spliterators, of which there are only {@code int}, {@code long}, and {@code double}.
	 *
	 * @return a widened primitive spliterator on the elements of this collection.
	 * @since 8.3.0
	 */
	@Override
	default KEY_WIDENED_SPLITERATOR KEY_WIDENED_SPLITERATOR_METHOD() {
		if (this instanceof ImplementsSpliterator) {
			return SPLITERATORS.widen(spliterator());
		} else {
			return WIDENED_SPLITERATORS.AS_KEY_WIDENED_SPLITERATOR(Spliterators.spliterator(
					KEY_WIDENED_ITERATOR_METHOD(), getSizeOf(this), SPLITERATORS.COLLECTION_SPLITERATOR_CHARACTERISTICS));
		}
	}
#elif defined JDK_PRIMITIVE_ITERATOR && KEYS_PRIMITIVE && !KEY_WIDENED && SMALL_TYPES
	/** Returns a primitive spliterator on the elements of this collection.<p>
	 *
	 * This method is identical to {@link #spliterator()}, as the type-specific
	 * spliterator is already compatible with the JDK's primitive spliterators.
	 * It only exists for compatibility with the other primitive types' {@code Collection}s
	 * that have use for widened spliterators.
	 *
	 * @return a primitive spliterator on the elements of this collection.
	 */
	@Override
	default KEY_WIDENED_SPLITERATOR KEY_WIDENED_SPLITERATOR_METHOD() { return spliterator(); }
#endif


#if KEYS_PRIMITIVE

	/** Ensures that this collection contains the specified element (optional operation).
	 * @see Collection#add(Object)
	 */
	boolean add(KEY_TYPE key);

	/** Returns {@code true} if this collection contains the specified element.
	 * @see Collection#contains(Object)
	 */
	boolean contains(KEY_TYPE key);

	/** Removes a single instance of the specified element from this
	 * collection, if it is present (optional operation).
	 *
	 * <p>Note that this method should be called {@link java.util.Collection#remove(Object) remove()}, but the clash
	 * with the similarly named index-based method in the {@link java.util.List} interface
	 * forces us to use a distinguished name. For simplicity, the set interfaces reinstates
	 * {@code remove()}.
	 *
	 * @see Collection#remove(Object)
	 */
	boolean rem(KEY_TYPE key);

	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Deprecated
	@Override
	default boolean add(final KEY_GENERIC_CLASS key) {
		return add(KEY_CLASS2TYPE(key));
	}

	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Deprecated
	@Override
	default boolean contains(final Object key) {
		if (key == null) return false;
		return contains(KEY_OBJ2TYPE(key));
	}

	/** {@inheritDoc}
	 * @deprecated Please use (and implement) the {@code rem()} method instead.
	 */
	@Deprecated
	@Override
	default boolean remove(final Object key) {
		if (key == null) return false;
		return rem(KEY_OBJ2TYPE(key));
	}

	/** Returns a primitive type array containing the items of this collection.
	 * @return a primitive type array containing the items of this collection.
	 * @see Collection#toArray()
	 */
	KEY_TYPE[] TO_KEY_ARRAY();

	/** Returns a primitive type array containing the items of this collection.
	 *
	 * <p>Note that, contrarily to {@link Collection#toArray(Object[])}, this
	 * methods just writes all elements of this collection: no special
	 * value will be added after the last one.
	 *
	 * @param a if this array is big enough, it will be used to store this collection.
	 * @return a primitive type array containing the items of this collection.
	 * @see Collection#toArray(Object[])
	 * @deprecated Please use {@code toArray()} instead&mdash;this method is redundant and will be removed in the future.
	 */
	@Deprecated
	default KEY_TYPE[] TO_KEY_ARRAY(KEY_TYPE a[]) {
		return toArray(a);
	}

	/** Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array.
	 *
	 * <p>Note that, contrarily to {@link Collection#toArray(Object[])}, this
	 * methods just writes all elements of this collection: no special
	 * value will be added after the last one.
	 *
	 * @param a if this array is big enough, it will be used to store this collection.
	 * @return a primitive type array containing the items of this collection.
	 * @see Collection#toArray(Object[])
	 */
	KEY_TYPE[] toArray(KEY_TYPE a[]);

	/** Adds all elements of the given type-specific collection to this collection.
	 *
	 * @param c a type-specific collection.
	 * @see Collection#addAll(Collection)
	 * @return {@code true} if this collection changed as a result of the call.
	 */
	boolean addAll(COLLECTION c);

	/** Checks whether this collection contains all elements from the given type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @see Collection#containsAll(Collection)
	 * @return {@code true} if this collection contains all elements of the argument.
	 */
	boolean containsAll(COLLECTION c);

	/** Remove from this collection all elements in the given type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @see Collection#removeAll(Collection)
	 * @return {@code true} if this collection changed as a result of the call.
	 */
	boolean removeAll(COLLECTION c);

#ifdef JDK_PRIMITIVE_PREDICATE
	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Deprecated
	@Override
	default boolean removeIf(final java.util.function.Predicate<? super KEY_GENERIC_CLASS> filter) {
		return removeIf((JDK_PRIMITIVE_PREDICATE) key -> filter.test(KEY2OBJ(KEY_NARROWING(key))));
	}

	/** Remove from this collection all elements which satisfy the given predicate.
	 *
	 * @param filter a predicate which returns {@code true} for elements to be
	 *        removed.
	 * @see Collection#removeIf(java.util.function.Predicate)
	 * @return {@code true} if any elements were removed.
	 */
	@SuppressWarnings("overloads")
	default boolean removeIf(final JDK_PRIMITIVE_PREDICATE filter) {
		java.util.Objects.requireNonNull(filter);
		boolean removed = false;
		final KEY_ITERATOR each = iterator();
		while (each.hasNext()) {
			if (filter.test(each.NEXT_KEY())) {
				each.remove();
				removed = true;
			}
		}
		return removed;
	}
#endif

	/** Retains in this collection only elements from the given type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @see Collection#retainAll(Collection)
	 * @return {@code true} if this collection changed as a result of the call.
	 */
	boolean retainAll(COLLECTION c);

#if defined JDK_PRIMITIVE_STREAM
	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Deprecated
	@Override
	default java.util.stream.Stream<KEY_GENERIC_CLASS> stream() { return Collection.super.stream(); }

	/** Return a primitive stream over the elements.
	 * @returns a primitive stream over the elements.
	 * @see Collection#stream()
	 */
	default JDK_PRIMITIVE_STREAM KEY_WIDENED_STREAM_METHOD() {
		return java.util.stream.StreamSupport.KEY_WIDENED_STREAM_METHOD(KEY_WIDENED_SPLITERATOR_METHOD(), false);
	}

	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead.
	 */
	@Deprecated
	@Override
	default java.util.stream.Stream<KEY_GENERIC_CLASS> parallelStream() { return Collection.super.parallelStream(); }

	/** Return a parallel primitive stream over the elements.
	 * @returns a parallel primitive stream over the elements.
	 * @see Collection#parallelStream()
	 */
	default JDK_PRIMITIVE_STREAM KEY_WIDENED_PARALLEL_STREAM_METHOD() {
		return java.util.stream.StreamSupport.KEY_WIDENED_STREAM_METHOD(KEY_WIDENED_SPLITERATOR_METHOD(), true);
	}
#endif

#endif

	/** An interface indicating the Collection has an explicit implementation of
	 * {@link java.util.Collection#spliterator()}, and not a default one. This is accomplished
	 * by reabstracting the default {@code spliterator} method this type specific collection defines.
	 *
	 * <p>This interface is primarily used to signal to a primitive widened spliterator method (e.g
	 * {@link it.unimi.dsi.fastutil.shorts.ShortCollection#intSpliterator())}
	 * that it should wrap the result of {@link java.util.Collection#spliterator()}, instead
	 * of avoiding that because {@code spliterator} could call the widened method.
	 * 
	 * <p>This interface extends the type-specific Collection interface so that if both appear in
	 * the list of implemented interfaces, the abstract {@code spliterator()} will take priority
	 * over the default method. It doesn't logically represent a new kind of Collection. This
	 * interface should be treated like the abstract classes, used only as an implementation
	 * aid and not as a variable type. 
	 *
	 * <p>You generally don't need to worry about this interface unless you are implementing
	 * your own type-specific Collection class.
	 */
	public static interface ImplementsSpliterator KEY_GENERIC extends COLLECTION KEY_GENERIC {
		// Reabstract the inappropriate default from Collection
		@Override
		abstract KEY_SPLITERATOR KEY_GENERIC spliterator();

#if defined JDK_PRIMITIVE_SPLITERATOR && KEY_WIDENED
		@Override
		default KEY_WIDENED_SPLITERATOR KEY_WIDENED_SPLITERATOR_METHOD() {
			return SPLITERATORS.widen(spliterator());
		}
#endif
	}
}
